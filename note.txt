issue
문제:
background.ts에서 드래그한 문자열의 글자 수와 바이트를 계산할 때 맨 끝의 공백이
selectionText에서 trim되는 것처럼 보이는 문제. "홍길동 "을 드래그하면 아무 처리도 안 했는데 "홍길동"으로 나옴
원인:
selectionText가 문자열을 가져올 때 드래그한 텍스트 끝에 공백이 있어도
렌더링상으로 보이지 않으면 브라우저가 자동으로 잘라내서 넘겨주기 때문이다.
이것이 Selection 객체에서 텍스트를 반환할 때 trim되는 것처럼 보이는 현상의 원인이다.
드래그가 inline 요소 사이거나 마지막에 공백이 있으면 정확히 일치하지 않을 수 있다.
해결법:
window.getSelection().getRangeAt(0)으로 Range 객체를 가져오면 드래그한 정확한 영역을 다룰 수 있다.
비고:
Range는 실제로 사용자가 어디서부터 어디까지 드래그했는지 정확히 표현해주는데
이후 range.cloneContents()로 사용자가 선택한 DOM 조각을 복사하고
임시로 div 객체를 만들어 넣은 뒤 div.textContent로 텍스트만 뽑아내면 된다.
이 과정을 chrome.scripting.executeScript({})로 감싸고
두 번째 인자에 스크립트 실행 결과를 처리하는 콜백 함수를 작성해 후처리한다.

문제:
background.ts, popup.ts에서 동일한 함수 byteCounter를 사용해야 함
utils/byteCounter.ts로 빼서 export시키고 각각 import해서 사용하려 했는데
크롬에서 Service worker registration failed. Status code: 15 오류와
Uncaught SyntaxError: Cannot use import statement outside a module 오류를 내는 문제
manifest.json에서 "service_worker": "src/background.js"를 제대로 인식하지 못함
popup.ts에서는 정상 작동
요약 - background.ts에서 import문을 사용한 byteCounter 모듈 불러오기가 작동하지 않음
원인:
manifest.json의 background 부분에 type: "module" 설정을 하지 않았기 때문이다.
이 설정을 해야 ESM으로 인식해 ES6+ 모듈이 활성화되어 import, export사용이 가능하다.
해결법:
manifest.json에서 type: "module"을 추가한다.
비고:
type: "module"설정을 했을 때 생기는 변화
1. import / export 사용 가능
2. 모듈 스코프(엄격 모드)
기본적으로 모듈 스코프를 가지기 때문에 var같은 전역 오염이 안 된다.
또 자동으로 use strict가 적용되어 엄격 모드가 강제된다.
this의 경우 undefined로 평가되어 전역 객체가 아니다.(window나 globalThis를 직접 써야 함)
3. 지연 로딩
모듈은 지연 로딩을 기본으로 한다. DOMContentLoaded 이전에 실행되지 않고 HTML이 파싱된 이후 실행
단, 크롬 확장의 service_worker에서는 바로 실행
4. import.meta 지원
import.meta.url로 현재 모듈의 절대경로를 가져올 수 있다.
5. MIME 타입이 text/javascript로 강제됨
모듈 스크립트는 명시적으로 MIME 타입이 text/javascript여야만 실행이 가능하다.
이 타입이 아닌 파일은 브라우저가 차단함
6. chrome.runtime.getBackgroundPage() 사용 불가능
대신 chrome.runtime.sendMessage()나 chrome.runtime.connect()같은 메시징 API를 사용하면 된다.

문제:
background.js에서 import는 정상적으로 되지만, 사용이 불가능한 문제
전역 컨텍스트에서 console.log에 찍으면 가능하나, 본격적인 코드 내부에선 작동하지 않음
원인:
chrome.scripting.executeScript 내부에서 import된 함수가 필요한데
이 내부에서는 백그라운드에서 실행한 함수를 가져가는 것이 아니다.
func: a는 그 탭의 컨텍스트에서 실행되는 함수라서 외부에서 정의된 변수나 함수는 정의되어있지 않다.
요약하면 별도 컨텍스트라서 외부 변수나 함수를 쓰지 못한다.
해결법:
동일한 함수 구문을 executeScript 안에 작성한다.
유지보수성을 약간 희생하지만 가장 간단하고 직관적
비고:
모듈화하는 방안도 있는 것 같은데 더 찾아봐야 함

문제:
content.js에서 import문이 사용 불가능한 현상
원인:
Manifest V3에서 type: "module"을 지원하기 시작했는데, 모든 곳에서 다 되는 건 아니고 제약이 있다.
content_scripts는 아직 해당 사항이 없다.
해결법:
번들링을 해서 import를 없애거나, 그냥 import할 구문을 그 위치에 작성해야 한다.

문제:
html 태그에서 얻은 string과 juso[]에서 얻은 string이 같은 문자열인데 서로 불일치하는 현상
원인:
html 태그에서 얻은 string 마지막에 줄바꿈 문자(\n, U+000A)가 포함되어 있었다.
해결법:
trim()을 사용하여 해결

문제:
파일 선택하여 연 이후 다시 파일 선택 창에 들어간 뒤 취소하면 기존 파일이 사라지는 문제
원인:
파일을 보여주는 오버레이 삭제 시점이 너무 일렀기 때문이다.
해결법:
오버레이 삭제 작업 시점을 오버레이 재구성 및 생성 바로 이전으로 이동시켜서 해결

문제:
색 추출 작업 중 이미지에서 색상 선택하기엔 popup.html의 창 크기가 애매한 문제
원인:
크롬 확장 팝업은 최대 800x600 사이즈가 한계
해결법:
새 탭을 열어 거기에 이미지가 표시되게 해서 해결

문제:
색 추출 작업 중 새 탭에서 연 이미지를 여는 속도가 지나치게 느린 문제
원인:
불필요한 base64 인코딩/디코딩 작업 때문에 브라우저에서 여는 데 많은 시간 필요
해결법:
base64 절차를 제거해서 해결

문제:
색 추출 작업 중 새 탭(colorpicker.html)으로 연 이미지가 있는 페이지에서 background.ts에서 색 추출 기능이 동작하지 않는 문제
원인:
chrome.scripting.executeScript같은 API는 외부 욉사이트(https://...)나 manifest에 명시적으로
권한을 부연한 URL에 대해서만 사용할 수 있으나,
크롬 확장 페이지 URL(자기 자신의 확장 리소스)은 권한 부여가 불가능하기 때문이다.
확장 프로그램의 내부 페이지는 이미 자체적으로 로드되고 스크립트를 포함하고 있기 때문에
크롬은 이 내부 페이지를 보호된 영역으로 보고 외부에서(background, popup)의 임의 코드 주입을 막는다.
해결법:
독립된 자체 스크립트 colorpicker.ts를 만들어 유사한 기능을 작성해 해결


문제:
서버 인증용으로 발급되어 클라이언트에 저장된 토큰이 서버에서 너무 빠르게 만료되는 현상
원인:
Cloudflare Workers에서는 일정 시간 대기하는 경우 컨테이너 메모리 전체가 날아가면서
같이 저장된 토큰 또한 초기화되기 때문에 서버에 토큰이 남아있지 않게 됨
해결법:
Workers KV나 Durable Object에 저장하는 것도 방법이지만,
현재로서는 소규모의 트래픽이 예상되는 작업에 과하다고 판단하여
매번 페이지를 열 때마다 토큰을 발급하게 수정 및 일정 조건을 걸어 과다 발급을 제한하여 해결

문제:
프로젝트 내에서 Bulma CSS를 여러 모듈(setting.ts, popup.ts)에서 중복 임포트할 경우
popup.html의 버튼 레이아웃이 의도와 다르게 가로 중앙 정렬되어 UI가 깨지는 현상 발생

원인:
Bulma CSS가 여러 엔트리포인트에서 중복으로 임포트되면서 빌드 과정에서 CSS가 중복 적용되고
그에 따른 스타일 우선순위 충돌로 인해 popup.html 내 버튼의 기본 정렬 스타일이 덮어씌워짐

해결법:
Bulma CSS 임포트를 별도의 파일(import-bulma.ts)로 분리하여 해당 파일에서 전역적으로 임포트하도록 구조 변경
setting.ts과 popup.ts에서 import-bulma.ts를 임포트하여 Bulma 스타일을 불러오게 하여 해결

todo
- popup.ts에 남아있는 innerHTML 제거하기

suggest
- 사용법 설명하는 페이지 만들기. 굳이 페이지 아니더라도 간단하게 안내하는 것도 괜찮음
- 단위 변환기에서 영어로 입력 가능한 단위라면 (kg, inch 등등) 이걸로 검색할 수 있도록 해보기
- 초성 관련 문제. ㄱ에서도 기에서도 길ㅇ에서도 "길이"가 나오도록 하기?
- 도로명주소 변경 기능은 api 활용하기 https://business.juso.go.kr/addrlink/openApi/apiExprn.do
- 한영타 변환 단축키에 등록?
- 글자 수 세기에 정규화 기능 추가?
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
- 단위 변환 검색창에서 엔터키를 누를 때 일치하는 요소가 없을 경우, item이 존재한다면 가장 위에 있는 item return하기
- 단위 변환 검색창에서 아래, 위 키보드 누르면 항목 이동할 수 있게 하기?
- css 교통정리 필요

suggest(complete)
- 드롭다운 박스에 검색 기능이 추가된 select2를 사용할 수 있음(https://select2.org/)(직접 구현함)
- 단위 변환기 초기 세팅을 길이로 하기(적용)
- 대단위에서 엔터키 누르면 검색한 거 입력필드에 넣기(적용)
- 단위 변환 탭키로 요소 이동하는 거 고민해보기(적용)
- 패널 변경 시 자동 포커스(적용)

Reference
- 글자수 세는 방법
https://medium.com/@vagabond95/%EA%B8%80%EC%9E%90%EC%88%98%EB%A5%BC-%EC%84%B8%EB%8A%94-%EB%B0%A9%EB%B2%95-4e35b37ad90f

- 토스트 메시지
https://www.google.com/search?newwindow=1&sca_esv=94c092591444690d&q=%ED%86%A0%EC%8A%A4%ED%8A%B8+%EB%A9%94%EC%8B%9C%EC%A7%80&udm=2&fbs=ABzOT_CZsxZeNKUEEOfuRMhc2yCI6hbTw9MNVwGCzBkHjFwaK53DgNHTMxn53_XGiUHS2MvCJOyRBFAs1hn9fBmZ19LYQ9yir0OaCtXuvoNzG8-dHmcRTmmsRqZ5k2cSbGmqEOzbPeKK3_yeEwDTB0-yQ8hPn4ZIpFFaP5lIIYo78XEtUm4eOu_MLKQQKyyvx_AVHgdb7Sce9eZwaQ0p6CoLuRlZrqo34A&sa=X&ved=2ahUKEwjBtbHgn5iMAxXf3zQHHVGVFOQQtKgLegQIFBAB&biw=1270&bih=1354&dpr=1.5

- 커스텀 select 메뉴 검색
https://stickode.tistory.com/675

- 한영타 변환 로직
https://github.com/738/inko/blob/master/index.js

타입스크립트 서버 재시작
Cmd+Shift+P (Ctrl+Shift+P)
> TypeScript: Restart TS server



// 0.3초 지연실행 적용된 한영타 변환 메인 실행 함수
let debounceTimer: number | undefined;

function hangulAlphabetConvertAction(e: Event) {
  // 한글 필드인지 영어 필드인지 구분
  let isHangul: Boolean = true;
  if ((e.target as HTMLElement).id === "hangul-alphabet-convert-input-eng") {
    isHangul = false;
  }

  // 한글 <-> 영어 상호 변환
  if (isHangul === true) {
    // 한글 -> 영어
    let hangulValue: string = (e.target as HTMLTextAreaElement).value;

    clearTimeout(debounceTimer); // 이전 타이머 취소

    // 0.3초 후에 실행
    debounceTimer = setTimeout(() => {
      const result: string = korEngLogic(hangulValue);

      const engDom = document.getElementById(
        "hangul-alphabet-convert-input-eng"
      ) as HTMLTextAreaElement;

      if (engDom) engDom.value = result;
    }, 300);
  } else {
    // 영어 -> 한글
    let alphabetValue: string = (e.target as HTMLTextAreaElement).value;

    clearTimeout(debounceTimer); // 이전 타이머 취소

    // 0.3초 후에 실행
    debounceTimer = setTimeout(() => {
      const result: string = engKorLogic(alphabetValue); // 조합된 한글이 여기에 들어감
      if (result === "fail") {
        console.error("변환 실패");
        return;
      }

      // 반대쪽 input에 적용
      const korDom = document.getElementById(
        "hangul-alphabet-convert-input-kor"
      ) as HTMLTextAreaElement;

      if (korDom) korDom.value = result;
    }, 300);
  }
}




문제
    function printCharCodes(str: string) {
      return [...str]
        .map((char, i) => {
          return `${i}: '${char}' (U+${char
            .charCodeAt(0)
            .toString(16)
            .toUpperCase()
            .padStart(4, "0")})`;
        })
        .join("\n");
    }

    const str1 = clkedRoad as string; // 길이 21
    const str2 = jusoArray[0].roadAddrPart1; // 길이 20

    console.log(
      "문자열 1 (길이: " + str1.length + ")\n" + printCharCodes(str1)
    );
    console.log(
      "\n문자열 2 (길이: " + str2.length + ")\n" + printCharCodes(str2)
    );